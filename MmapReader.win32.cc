// Generated by an GLM 4.6 model, as I don't have the means
// (yet) to test on Windows. Fingers crossed.
// MmapReader.win32.cpp
#define WIN32_LEAN_AND_MEAN
#include "MmapReader.h"
#include <print>
#include <stdexcept>
#include <windows.h>

class MmapReaderWin32 : public MmapReaderBase {
public:
  explicit MmapReaderWin32(const std::string &filename) {
    // 1. Create a handle to the file
    file_handle = CreateFileA(filename.c_str(), GENERIC_READ, FILE_SHARE_READ,
                              NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (file_handle == INVALID_HANDLE_VALUE) {
      // throw std::runtime_error("Failed to open file: " + filename);
      std::println("Failed to open file: {}", filename);
      return;
    }

    // 2. Get the file size
    LARGE_INTEGER file_size_large;
    if (!GetFileSizeEx(file_handle, &file_size_large)) {
      CloseHandle(file_handle);
      // throw std::runtime_error("Failed to get file size for: " + filename);
      std::println("Failed to get file size for: {}", filename);
    }
    file_size = static_cast<size_t>(file_size_large.QuadPart);

    if (file_size > 0) {
      // 3. Create a file mapping object
      map_handle =
          CreateFileMapping(file_handle, NULL, PAGE_READONLY, 0, 0, NULL);
      if (map_handle == NULL) {
        CloseHandle(file_handle);
        // throw std::runtime_error("Failed to create file mapping for: " +
        //                          filename);
        std::println("Failed to create file mapping for: {}", filename);
      }

      // 4. Map a view of the file into the address space
      mapped_data = static_cast<char *>(
          MapViewOfFile(map_handle, FILE_MAP_READ, 0, 0, file_size));
      if (mapped_data == NULL) {
        CloseHandle(map_handle);
        CloseHandle(file_handle);
        // throw std::runtime_error("Failed to map view of file: " + filename);
        std::println("Failed to map view of file: {}", filename);
      }
    }

    m_is_open = true;
  }

  ~MmapReaderWin32() override {
    if (mapped_data != NULL) {
      UnmapViewOfFile(mapped_data);
    }
    if (map_handle != NULL) {
      CloseHandle(map_handle);
    }
    if (file_handle != INVALID_HANDLE_VALUE) {
      CloseHandle(file_handle);
    }
    m_is_open = false;
  }

  // Rule of Five
  MmapReaderWin32(const MmapReaderWin32 &) = delete;
  MmapReaderWin32 &operator=(const MmapReaderWin32 &) = delete;
  MmapReaderWin32(MmapReaderWin32 &&other) noexcept
      : file_handle(other.file_handle), map_handle(other.map_handle),
        mapped_data(other.mapped_data), file_size(other.file_size) {
    other.file_handle = INVALID_HANDLE_VALUE;
    other.map_handle = NULL;
    other.mapped_data = NULL;
    other.file_size = 0;
  }
  MmapReaderWin32 &operator=(MmapReaderWin32 &&other) noexcept {
    if (this != &other) {
      if (mapped_data != NULL)
        UnmapViewOfFile(mapped_data);
      if (map_handle != NULL)
        CloseHandle(map_handle);
      if (file_handle != INVALID_HANDLE_VALUE)
        CloseHandle(file_handle);

      file_handle = other.file_handle;
      map_handle = other.map_handle;
      mapped_data = other.mapped_data;
      file_size = other.file_size;

      other.file_handle = INVALID_HANDLE_VALUE;
      other.map_handle = NULL;
      other.mapped_data = NULL;
      other.file_size = 0;
    }
    return *this;
  }

  const char *get_data() const override { return mapped_data; }
  size_t get_size() const override { return file_size; }
  bool is_open() const override { return m_is_open; };

private:
  HANDLE file_handle = INVALID_HANDLE_VALUE;
  HANDLE map_handle = NULL;
  char *mapped_data = NULL;
  size_t file_size = 0;
  bool m_is_open = false;
};

// Factory implementation for Windows
std::unique_ptr<MmapReaderBase>
create_mmap_reader(const std::string &filename) {
  return std::make_unique<MmapReaderWin32>(filename);
}
